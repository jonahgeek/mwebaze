exports.ids = [2];
exports.modules = {

/***/ "./writings/dark-mode-enabled.md":
/*!***************************************!*\
  !*** ./writings/dark-mode-enabled.md ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"---\\ntitle: \\\"Enabled dark mode with styled-components\\\"\\ndate: \\\"2020-01-08\\\"\\nauthor:\\n  twitter: \\\"telmo\\\"\\n  name: \\\"Telmo Goncalves\\\"\\n---\\n\\nAfter creating this blog, I thought it would be good to be part of all\\nthe **Dark Mode** hype. And since I've never done it, I tried it out.\\n\\n![](https://img.onl/ksEPSi)\\n> Outdated version of my blog\\n\\nSince I'd never really worked with NextJS aside from building this blog,\\nI had to do some research before getting my hands dirty.\\n\\n<br />\\n\\nFor this tutorial, I'll continue using the code from [this post](/writings/nextjs-blog-in-less-than-1-hour),\\nalthough I'll leave the changes for this tutorial in a branch called `dark-mode`.\\n\\n---\\n\\n## All right, let's get started\\n\\nFor this to happen we'll be using `styled-components`, if you're not familiar with it,\\nI would suggest you take a quick look into [their documentation](https://www.styled-components.com/docs/basics#getting-started).\\n\\n<br />\\n\\nIn the root of your projects let us create a `styles` folder and a `themes.js` file:\\n\\n```bash\\nmkdir styles && touch styles/themes.js\\n```\\n\\nAll right, we need a `light` and a `dark` theme, for that we can simply create 2 objects,\\none for each theme:\\n\\n```js\\nexport const lightTheme = {\\n  body: '#FFFFFF',\\n  text: '#363537',\\n}\\n\\nexport const darkTheme = {\\n  body: '#101010',\\n  text: '#FAFAFA',\\n}\\n\\n```\\n\\nDon't worry about this for now, we'll be using it later.\\n\\n<br />\\n\\nWhat I've done was creating a `Layout` wrapper that contains my global styles, theme styles and so forth.\\nBut before that let's define our global styles:\\n\\n```bash\\ntouch styles/global.js\\n```\\n\\nInside `global.js` we'll be using `styled-components`, so let's take care of install it:\\n\\n```bash\\nnpm install styled-components --save\\n```\\n\\n<br />\\n\\nLet's start with something simple such as, background and text color:\\n\\n```js\\nimport { createGlobalStyle } from 'styled-components';\\n\\n// the `theme` object is comming from our ./themes.js file\\nexport const GlobalStyles = createGlobalStyle`\\n  body {\\n    background-color: ${({ theme }) => theme.body};\\n    color: ${({ theme }) => theme.text}\\n  }\\n`\\n```\\n\\n<br />\\n\\nCool, we should be done with this, let's look into implement the themes.\\n\\n---\\n\\n## Layout and Theme Switch\\n\\nI've mentioned that I used a `Layout` wrapper to take care of styles, themes, and so forth. Let's\\ncreate that wrapper:\\n\\n```bash\\nmkdir components && touch components/Layout.js\\n```\\n\\n<br />\\n\\nPaste the following into `Layout.js`:\\n\\n```js\\nimport React from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\n// Default dark mode to true for now\\nconst darkMode = true\\n\\nfunction Layout({ children }) {\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nWe should be ready to wrap our pages with `Layout`, if you look at the codebase\\nI've provided at the beginning of this tutorial you should see a file `/pages/index.js`,\\non that file change the following lines:\\n\\n```js:3,7,9\\nimport React from 'react'\\n\\nimport Layout from '../components/Layout'\\n\\nexport default function Index(props) {\\n  return (\\n    <Layout>\\n      ‚úçÔ∏è My blog about {props.blogCategory}\\n    </Layout>\\n  )\\n}\\n\\nIndex.getInitialProps = () => {\\n  return {\\n    blogCategory: 'ReactJS'\\n  }\\n}\\n```\\n\\nRun the following commands and access your application at `http://localhost:3000`:\\n\\n```bash\\nnpm install && npm run dev\\n```\\n\\nYou should see the background turned dark and the text white ü•≥\\n\\n<br />\\n\\n### Let there be light\\n\\nLet's change the `Layout` wrapper to allow us to switch between dark and light mode. Go\\nto the `components/Layout.js` file and let's make some changes:\\n\\n```js:!-1,-7-8,11-12\\nimport React, { useState } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\n// Default dark mode to true for now\\nconst darkMode = true\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nIf you refresh the page, you should see the same behaviour: dark background, white text.\\n\\n<br />\\n\\nLet's make a quick change to check if our **Light** theme is working as well, change\\nour `darkMode` state from `true` to `false`:\\n\\n```js:!-3\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(false)\\n\\n  // ...\\n}\\n```\\n\\nRefresh the page; you should see the original theme: white background, dark text üëå\\n\\n<br />\\n\\n#### The Switch\\n\\nWe'll be using the `setDarkMode` method from the previous code, we'll create a\\n`<button>` with an `onClick` prop:\\n\\n```js:14-18\\nimport React, { useState } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nSo, what are we doing with `onClick={() => setDarkMode(!darkMode)}`, we're setting\\nthe `darkMode` state by using the `! (not)` operator, which inverts the boolean expression:\\n\\n```js\\nlet darkMode = true\\n\\ndarkMode = !darkMode // false\\ndarkMode = !darkMode // true\\n```\\n\\n---\\n\\n## Persistence\\n\\nYou should notice that every time you refresh your application and theme falls back to the light theme,\\nwell, let's deal with that.\\n\\n<br />\\n\\nFor that we'll take advantage of `localStorage` and React Hooks `useEffect` method. Let's take a look:\\n\\n```js:!-1,11-13\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  useEffect(() => {\\n    console.log(`Using dark mode? ${darkMode}`)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nOpen your developer console, every time you switch between light and dark mode, you should\\nsee logs such as:\\n\\n```text\\nUsing dark mode? false\\nUsing dark mode? true\\nUsing dark mode? false\\n```\\n\\nGreat, that means `useEffect` is working as expected. Although, is you refresh the page\\nit keeps falling back to the light theme.\\n\\n<br />\\n\\nLet's use `localStorage` to fix that:\\n\\n```js:-12,13\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  useEffect(() => {\\n    console.log(`Using dark mode? ${darkMode}`)\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nYou can check if this is working as expected in the developer tools console,\\nunder **Application ‚Üí Local Storage ‚Üí http://localhost:3000**, you should see:\\n\\n| Key        | Value |\\n| ------------- | ------------- |\\n| `DARK_MODE`      | `true` or `false` |\\n\\n<br />\\n\\nOnce again, on refresh it's still falling back to the light theme, to fix that we\\nneed to make a small change, we need to get the value from `localStorage` and\\nset as our default `darkMode` state:\\n\\n```js:!-9,11-15\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n  }, [])\\n\\n  useEffect(() => {\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n         <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nWe could have got the `localStorage` value before setting the state, but `localStorage`\\nis still not available because it's not part of NextJS, so this is a nice work-around.\\n\\n---\\n\\n## What the flash?\\n\\nYou might have noticed that when reloading your application while in dark mode,\\nthe page kind of _flashes_ between light and dark mode. Well, we also can use `useEffect`\\nas a good work-around to prevent that, let's set another state ‚Äì `mounted`:\\n\\n```js:6,12-13\\n// ...\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n  const [mounted, setMounted] = useState(false)\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n    // Set mounted to `true` only after setting the `darkMode` state\\n    setMounted(true)\\n  }, [])\\n\\n  // ...\\n}\\n```\\n\\nAlright, now we can simply render an empty `<div />` before the component has been mounted,\\nthis will prevent the component to render our styles, `ThemeProvider` etc before we set the\\n`darkMode` state:\\n\\n```js:24\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n  const [mounted, setMounted] = useState(false)\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n    // Set mounted to `true` only after setting the `darkMode` state\\n    setMounted(true)\\n  }, [])\\n\\n  useEffect(() => {\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  if (!mounted) return <div />\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n         <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nIf you reload your application, the _flash_ between light and dark mode should be gone.\\n\\n---\\n\\n## Source Code\\n\\nYou can find the source code of this tutorial [here](https://github.com/telmogoncalves/nextjs-markdown-blog),\\ndon't forget it's under the branch `dark-mode`.\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93cml0aW5ncy9kYXJrLW1vZGUtZW5hYmxlZC5tZD8wNTE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUseXlDQUEwdUMsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsMmdCQUEyZ0Isb0JBQW9CLDBCQUEwQix3SEFBd0gsMEJBQTBCLEVBQUUsUUFBUSxpQkFBaUIsZUFBZSxFQUFFLFFBQVEsZ0JBQWdCLEtBQUssK1pBQStaLGdCQUFnQixxQ0FBcUMsZUFBZSxrQ0FBa0Msd0JBQXdCLDRHQUE0RyxXQUFXLEdBQUcsMEhBQTBILGtDQUFrQyxrQ0FBa0MsU0FBUyw4QkFBOEIsc1hBQXNYLG9EQUFvRCxtQkFBbUIsdUJBQXVCLG1DQUFtQyxZQUFZLGtDQUFrQyxHQUFHLG1iQUFtYixXQUFXLHVCQUF1QixnQkFBZ0IscUNBQXFDLGVBQWUsa0NBQWtDLHdCQUF3Qiw0R0FBNEcsV0FBVyxHQUFHLHdOQUF3TixrQ0FBa0Msa0NBQWtDLFNBQVMsOEJBQThCLDBTQUEwUyxXQUFXLEdBQUcsNEdBQTRHLDBCQUEwQixxUEFBcVAsV0FBVyx1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNkNBQTZDLFdBQVcsR0FBRyx3TkFBd04sa0NBQWtDLHlDQUF5Qyw2QkFBNkIsY0FBYyxrREFBa0Qsa0VBQWtFLFNBQVMsOEJBQThCLHVFQUF1RSw2QkFBNkIsd2dCQUF3Z0Isc0JBQXNCLHVCQUF1QixnQkFBZ0IscUNBQXFDLGVBQWUsa0NBQWtDLHdCQUF3Qiw2Q0FBNkMsV0FBVyxHQUFHLG1IQUFtSCxzQ0FBc0MsU0FBUyxPQUFPLDhLQUE4SyxrQ0FBa0MseUNBQXlDLDZCQUE2QixjQUFjLGtEQUFrRCxrRUFBa0UsU0FBUyw4QkFBOEIsZ2NBQWdjLHNCQUFzQix1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNkNBQTZDLFdBQVcsR0FBRyxtSEFBbUgsc0NBQXNDLFNBQVMsd0RBQXdELDhLQUE4SyxrQ0FBa0MseUNBQXlDLDZCQUE2QixjQUFjLGtEQUFrRCxrRUFBa0UsU0FBUyw4QkFBOEIsNmhCQUE2aEIsc0JBQXNCLHVCQUF1QixnQkFBZ0IscUNBQXFDLGVBQWUsa0NBQWtDLHdCQUF3Qiw2Q0FBNkMsV0FBVyxHQUFHLCtHQUErRyxrS0FBa0ssNEJBQTRCLHNEQUFzRCw4S0FBOEssa0NBQWtDLDBDQUEwQyw2QkFBNkIsY0FBYyxrREFBa0Qsb0VBQW9FLFNBQVMsOEJBQThCLHVoQkFBdWhCLFdBQVcsR0FBRyxnS0FBZ0ssOFBBQThQLG9CQUFvQixpUEFBaVAsc0JBQXNCLHVCQUF1QixnQkFBZ0IscUNBQXFDLGVBQWUsa0NBQWtDLHdCQUF3Qiw2Q0FBNkMsV0FBVyxHQUFHLGdLQUFnSyw4UEFBOFAsNEJBQTRCLHNEQUFzRCxnTkFBZ04sa0NBQWtDLDBDQUEwQyw2QkFBNkIsY0FBYyxrREFBa0Qsb0VBQW9FLFNBQVMsOEJBQThCLHVUQUF1VCIsImZpbGUiOiIuL3dyaXRpbmdzL2RhcmstbW9kZS1lbmFibGVkLm1kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIkVuYWJsZWQgZGFyayBtb2RlIHdpdGggc3R5bGVkLWNvbXBvbmVudHNcXFwiXFxuZGF0ZTogXFxcIjIwMjAtMDEtMDhcXFwiXFxuYXV0aG9yOlxcbiAgdHdpdHRlcjogXFxcInRlbG1vXFxcIlxcbiAgbmFtZTogXFxcIlRlbG1vIEdvbmNhbHZlc1xcXCJcXG4tLS1cXG5cXG5BZnRlciBjcmVhdGluZyB0aGlzIGJsb2csIEkgdGhvdWdodCBpdCB3b3VsZCBiZSBnb29kIHRvIGJlIHBhcnQgb2YgYWxsXFxudGhlICoqRGFyayBNb2RlKiogaHlwZS4gQW5kIHNpbmNlIEkndmUgbmV2ZXIgZG9uZSBpdCwgSSB0cmllZCBpdCBvdXQuXFxuXFxuIVtdKGh0dHBzOi8vaW1nLm9ubC9rc0VQU2kpXFxuPiBPdXRkYXRlZCB2ZXJzaW9uIG9mIG15IGJsb2dcXG5cXG5TaW5jZSBJJ2QgbmV2ZXIgcmVhbGx5IHdvcmtlZCB3aXRoIE5leHRKUyBhc2lkZSBmcm9tIGJ1aWxkaW5nIHRoaXMgYmxvZyxcXG5JIGhhZCB0byBkbyBzb21lIHJlc2VhcmNoIGJlZm9yZSBnZXR0aW5nIG15IGhhbmRzIGRpcnR5LlxcblxcbjxiciAvPlxcblxcbkZvciB0aGlzIHR1dG9yaWFsLCBJJ2xsIGNvbnRpbnVlIHVzaW5nIHRoZSBjb2RlIGZyb20gW3RoaXMgcG9zdF0oL3dyaXRpbmdzL25leHRqcy1ibG9nLWluLWxlc3MtdGhhbi0xLWhvdXIpLFxcbmFsdGhvdWdoIEknbGwgbGVhdmUgdGhlIGNoYW5nZXMgZm9yIHRoaXMgdHV0b3JpYWwgaW4gYSBicmFuY2ggY2FsbGVkIGBkYXJrLW1vZGVgLlxcblxcbi0tLVxcblxcbiMjIEFsbCByaWdodCwgbGV0J3MgZ2V0IHN0YXJ0ZWRcXG5cXG5Gb3IgdGhpcyB0byBoYXBwZW4gd2UnbGwgYmUgdXNpbmcgYHN0eWxlZC1jb21wb25lbnRzYCwgaWYgeW91J3JlIG5vdCBmYW1pbGlhciB3aXRoIGl0LFxcbkkgd291bGQgc3VnZ2VzdCB5b3UgdGFrZSBhIHF1aWNrIGxvb2sgaW50byBbdGhlaXIgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI2dldHRpbmctc3RhcnRlZCkuXFxuXFxuPGJyIC8+XFxuXFxuSW4gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0cyBsZXQgdXMgY3JlYXRlIGEgYHN0eWxlc2AgZm9sZGVyIGFuZCBhIGB0aGVtZXMuanNgIGZpbGU6XFxuXFxuYGBgYmFzaFxcbm1rZGlyIHN0eWxlcyAmJiB0b3VjaCBzdHlsZXMvdGhlbWVzLmpzXFxuYGBgXFxuXFxuQWxsIHJpZ2h0LCB3ZSBuZWVkIGEgYGxpZ2h0YCBhbmQgYSBgZGFya2AgdGhlbWUsIGZvciB0aGF0IHdlIGNhbiBzaW1wbHkgY3JlYXRlIDIgb2JqZWN0cyxcXG5vbmUgZm9yIGVhY2ggdGhlbWU6XFxuXFxuYGBganNcXG5leHBvcnQgY29uc3QgbGlnaHRUaGVtZSA9IHtcXG4gIGJvZHk6ICcjRkZGRkZGJyxcXG4gIHRleHQ6ICcjMzYzNTM3JyxcXG59XFxuXFxuZXhwb3J0IGNvbnN0IGRhcmtUaGVtZSA9IHtcXG4gIGJvZHk6ICcjMTAxMDEwJyxcXG4gIHRleHQ6ICcjRkFGQUZBJyxcXG59XFxuXFxuYGBgXFxuXFxuRG9uJ3Qgd29ycnkgYWJvdXQgdGhpcyBmb3Igbm93LCB3ZSdsbCBiZSB1c2luZyBpdCBsYXRlci5cXG5cXG48YnIgLz5cXG5cXG5XaGF0IEkndmUgZG9uZSB3YXMgY3JlYXRpbmcgYSBgTGF5b3V0YCB3cmFwcGVyIHRoYXQgY29udGFpbnMgbXkgZ2xvYmFsIHN0eWxlcywgdGhlbWUgc3R5bGVzIGFuZCBzbyBmb3J0aC5cXG5CdXQgYmVmb3JlIHRoYXQgbGV0J3MgZGVmaW5lIG91ciBnbG9iYWwgc3R5bGVzOlxcblxcbmBgYGJhc2hcXG50b3VjaCBzdHlsZXMvZ2xvYmFsLmpzXFxuYGBgXFxuXFxuSW5zaWRlIGBnbG9iYWwuanNgIHdlJ2xsIGJlIHVzaW5nIGBzdHlsZWQtY29tcG9uZW50c2AsIHNvIGxldCdzIHRha2UgY2FyZSBvZiBpbnN0YWxsIGl0OlxcblxcbmBgYGJhc2hcXG5ucG0gaW5zdGFsbCBzdHlsZWQtY29tcG9uZW50cyAtLXNhdmVcXG5gYGBcXG5cXG48YnIgLz5cXG5cXG5MZXQncyBzdGFydCB3aXRoIHNvbWV0aGluZyBzaW1wbGUgc3VjaCBhcywgYmFja2dyb3VuZCBhbmQgdGV4dCBjb2xvcjpcXG5cXG5gYGBqc1xcbmltcG9ydCB7IGNyZWF0ZUdsb2JhbFN0eWxlIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xcblxcbi8vIHRoZSBgdGhlbWVgIG9iamVjdCBpcyBjb21taW5nIGZyb20gb3VyIC4vdGhlbWVzLmpzIGZpbGVcXG5leHBvcnQgY29uc3QgR2xvYmFsU3R5bGVzID0gY3JlYXRlR2xvYmFsU3R5bGVgXFxuICBib2R5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ib2R5fTtcXG4gICAgY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudGV4dH1cXG4gIH1cXG5gXFxuYGBgXFxuXFxuPGJyIC8+XFxuXFxuQ29vbCwgd2Ugc2hvdWxkIGJlIGRvbmUgd2l0aCB0aGlzLCBsZXQncyBsb29rIGludG8gaW1wbGVtZW50IHRoZSB0aGVtZXMuXFxuXFxuLS0tXFxuXFxuIyMgTGF5b3V0IGFuZCBUaGVtZSBTd2l0Y2hcXG5cXG5JJ3ZlIG1lbnRpb25lZCB0aGF0IEkgdXNlZCBhIGBMYXlvdXRgIHdyYXBwZXIgdG8gdGFrZSBjYXJlIG9mIHN0eWxlcywgdGhlbWVzLCBhbmQgc28gZm9ydGguIExldCdzXFxuY3JlYXRlIHRoYXQgd3JhcHBlcjpcXG5cXG5gYGBiYXNoXFxubWtkaXIgY29tcG9uZW50cyAmJiB0b3VjaCBjb21wb25lbnRzL0xheW91dC5qc1xcbmBgYFxcblxcbjxiciAvPlxcblxcblBhc3RlIHRoZSBmb2xsb3dpbmcgaW50byBgTGF5b3V0LmpzYDpcXG5cXG5gYGBqc1xcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcXG5pbXBvcnQgeyBUaGVtZVByb3ZpZGVyIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnXFxuXFxuaW1wb3J0IHsgR2xvYmFsU3R5bGVzIH0gZnJvbSAnLi4vc3R5bGVzL2dsb2JhbCdcXG5pbXBvcnQgeyBsaWdodFRoZW1lLCBkYXJrVGhlbWUgfSBmcm9tICcuLi9zdHlsZXMvdGhlbWVzJ1xcblxcbi8vIERlZmF1bHQgZGFyayBtb2RlIHRvIHRydWUgZm9yIG5vd1xcbmNvbnN0IGRhcmtNb2RlID0gdHJ1ZVxcblxcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIHJldHVybiAoXFxuICAgIC8vIFRoaXMgd2lsbCBwYXNzIGB0aGVtZWAgZnJvbSBgVGhlbWVQcm92aWRlcmAgYXMgYSBwcm9wIGludG8gYEdsb2JhbFN0eWxlc2BcXG4gICAgPFRoZW1lUHJvdmlkZXIgdGhlbWU9e2RhcmtNb2RlID8gZGFya1RoZW1lIDogbGlnaHRUaGVtZX0+XFxuICAgICAgPEdsb2JhbFN0eWxlcyAvPlxcbiAgICAgIHtjaGlsZHJlbn1cXG4gICAgPC9UaGVtZVByb3ZpZGVyPlxcbiAgKVxcbn1cXG5cXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRcXG5gYGBcXG5cXG5XZSBzaG91bGQgYmUgcmVhZHkgdG8gd3JhcCBvdXIgcGFnZXMgd2l0aCBgTGF5b3V0YCwgaWYgeW91IGxvb2sgYXQgdGhlIGNvZGViYXNlXFxuSSd2ZSBwcm92aWRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgdHV0b3JpYWwgeW91IHNob3VsZCBzZWUgYSBmaWxlIGAvcGFnZXMvaW5kZXguanNgLFxcbm9uIHRoYXQgZmlsZSBjaGFuZ2UgdGhlIGZvbGxvd2luZyBsaW5lczpcXG5cXG5gYGBqczozLDcsOVxcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcXG5cXG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2NvbXBvbmVudHMvTGF5b3V0J1xcblxcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluZGV4KHByb3BzKSB7XFxuICByZXR1cm4gKFxcbiAgICA8TGF5b3V0PlxcbiAgICAgIOKcje+4jyBNeSBibG9nIGFib3V0IHtwcm9wcy5ibG9nQ2F0ZWdvcnl9XFxuICAgIDwvTGF5b3V0PlxcbiAgKVxcbn1cXG5cXG5JbmRleC5nZXRJbml0aWFsUHJvcHMgPSAoKSA9PiB7XFxuICByZXR1cm4ge1xcbiAgICBibG9nQ2F0ZWdvcnk6ICdSZWFjdEpTJ1xcbiAgfVxcbn1cXG5gYGBcXG5cXG5SdW4gdGhlIGZvbGxvd2luZyBjb21tYW5kcyBhbmQgYWNjZXNzIHlvdXIgYXBwbGljYXRpb24gYXQgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMGA6XFxuXFxuYGBgYmFzaFxcbm5wbSBpbnN0YWxsICYmIG5wbSBydW4gZGV2XFxuYGBgXFxuXFxuWW91IHNob3VsZCBzZWUgdGhlIGJhY2tncm91bmQgdHVybmVkIGRhcmsgYW5kIHRoZSB0ZXh0IHdoaXRlIPCfpbNcXG5cXG48YnIgLz5cXG5cXG4jIyMgTGV0IHRoZXJlIGJlIGxpZ2h0XFxuXFxuTGV0J3MgY2hhbmdlIHRoZSBgTGF5b3V0YCB3cmFwcGVyIHRvIGFsbG93IHVzIHRvIHN3aXRjaCBiZXR3ZWVuIGRhcmsgYW5kIGxpZ2h0IG1vZGUuIEdvXFxudG8gdGhlIGBjb21wb25lbnRzL0xheW91dC5qc2AgZmlsZSBhbmQgbGV0J3MgbWFrZSBzb21lIGNoYW5nZXM6XFxuXFxuYGBganM6IS0xLC03LTgsMTEtMTJcXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcXG5pbXBvcnQgeyBUaGVtZVByb3ZpZGVyIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnXFxuXFxuaW1wb3J0IHsgR2xvYmFsU3R5bGVzIH0gZnJvbSAnLi4vc3R5bGVzL2dsb2JhbCdcXG5pbXBvcnQgeyBsaWdodFRoZW1lLCBkYXJrVGhlbWUgfSBmcm9tICcuLi9zdHlsZXMvdGhlbWVzJ1xcblxcbi8vIERlZmF1bHQgZGFyayBtb2RlIHRvIHRydWUgZm9yIG5vd1xcbmNvbnN0IGRhcmtNb2RlID0gdHJ1ZVxcblxcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIC8vIFVzZSB0aGUgc3RhdGUgdG8gZGV0ZXJtaW5lIGRhcmtNb2RlXFxuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKHRydWUpXFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuSWYgeW91IHJlZnJlc2ggdGhlIHBhZ2UsIHlvdSBzaG91bGQgc2VlIHRoZSBzYW1lIGJlaGF2aW91cjogZGFyayBiYWNrZ3JvdW5kLCB3aGl0ZSB0ZXh0LlxcblxcbjxiciAvPlxcblxcbkxldCdzIG1ha2UgYSBxdWljayBjaGFuZ2UgdG8gY2hlY2sgaWYgb3VyICoqTGlnaHQqKiB0aGVtZSBpcyB3b3JraW5nIGFzIHdlbGwsIGNoYW5nZVxcbm91ciBgZGFya01vZGVgIHN0YXRlIGZyb20gYHRydWVgIHRvIGBmYWxzZWA6XFxuXFxuYGBganM6IS0zXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUoZmFsc2UpXFxuXFxuICAvLyAuLi5cXG59XFxuYGBgXFxuXFxuUmVmcmVzaCB0aGUgcGFnZTsgeW91IHNob3VsZCBzZWUgdGhlIG9yaWdpbmFsIHRoZW1lOiB3aGl0ZSBiYWNrZ3JvdW5kLCBkYXJrIHRleHQg8J+RjFxcblxcbjxiciAvPlxcblxcbiMjIyMgVGhlIFN3aXRjaFxcblxcbldlJ2xsIGJlIHVzaW5nIHRoZSBgc2V0RGFya01vZGVgIG1ldGhvZCBmcm9tIHRoZSBwcmV2aW91cyBjb2RlLCB3ZSdsbCBjcmVhdGUgYVxcbmA8YnV0dG9uPmAgd2l0aCBhbiBgb25DbGlja2AgcHJvcDpcXG5cXG5gYGBqczoxNC0xOFxcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xcbmltcG9ydCB7IFRoZW1lUHJvdmlkZXIgfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cydcXG5cXG5pbXBvcnQgeyBHbG9iYWxTdHlsZXMgfSBmcm9tICcuLi9zdHlsZXMvZ2xvYmFsJ1xcbmltcG9ydCB7IGxpZ2h0VGhlbWUsIGRhcmtUaGVtZSB9IGZyb20gJy4uL3N0eWxlcy90aGVtZXMnXFxuXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUodHJ1ZSlcXG5cXG4gIHJldHVybiAoXFxuICAgIC8vIFRoaXMgd2lsbCBwYXNzIGB0aGVtZWAgZnJvbSBgVGhlbWVQcm92aWRlcmAgYXMgYSBwcm9wIGludG8gYEdsb2JhbFN0eWxlc2BcXG4gICAgPFRoZW1lUHJvdmlkZXIgdGhlbWU9e2RhcmtNb2RlID8gZGFya1RoZW1lIDogbGlnaHRUaGVtZX0+XFxuICAgICAgPGRpdj5cXG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0RGFya01vZGUoIWRhcmtNb2RlKX0+XFxuICAgICAgICAgIHtkYXJrTW9kZSA/ICdMaWdodCBpdCB1cCEnIDogJ1R1cm4gdGhlIGxpZ2h0IG9mZiEnfVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPEdsb2JhbFN0eWxlcyAvPlxcbiAgICAgIHtjaGlsZHJlbn1cXG4gICAgPC9UaGVtZVByb3ZpZGVyPlxcbiAgKVxcbn1cXG5cXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRcXG5gYGBcXG5cXG5Tbywgd2hhdCBhcmUgd2UgZG9pbmcgd2l0aCBgb25DbGljaz17KCkgPT4gc2V0RGFya01vZGUoIWRhcmtNb2RlKX1gLCB3ZSdyZSBzZXR0aW5nXFxudGhlIGBkYXJrTW9kZWAgc3RhdGUgYnkgdXNpbmcgdGhlIGAhIChub3QpYCBvcGVyYXRvciwgd2hpY2ggaW52ZXJ0cyB0aGUgYm9vbGVhbiBleHByZXNzaW9uOlxcblxcbmBgYGpzXFxubGV0IGRhcmtNb2RlID0gdHJ1ZVxcblxcbmRhcmtNb2RlID0gIWRhcmtNb2RlIC8vIGZhbHNlXFxuZGFya01vZGUgPSAhZGFya01vZGUgLy8gdHJ1ZVxcbmBgYFxcblxcbi0tLVxcblxcbiMjIFBlcnNpc3RlbmNlXFxuXFxuWW91IHNob3VsZCBub3RpY2UgdGhhdCBldmVyeSB0aW1lIHlvdSByZWZyZXNoIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW1lIGZhbGxzIGJhY2sgdG8gdGhlIGxpZ2h0IHRoZW1lLFxcbndlbGwsIGxldCdzIGRlYWwgd2l0aCB0aGF0LlxcblxcbjxiciAvPlxcblxcbkZvciB0aGF0IHdlJ2xsIHRha2UgYWR2YW50YWdlIG9mIGBsb2NhbFN0b3JhZ2VgIGFuZCBSZWFjdCBIb29rcyBgdXNlRWZmZWN0YCBtZXRob2QuIExldCdzIHRha2UgYSBsb29rOlxcblxcbmBgYGpzOiEtMSwxMS0xM1xcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXFxuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJ1xcblxcbmltcG9ydCB7IEdsb2JhbFN0eWxlcyB9IGZyb20gJy4uL3N0eWxlcy9nbG9iYWwnXFxuaW1wb3J0IHsgbGlnaHRUaGVtZSwgZGFya1RoZW1lIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lcydcXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICAvLyBVc2UgdGhlIHN0YXRlIHRvIGRldGVybWluZSBkYXJrTW9kZVxcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSh0cnVlKVxcblxcbiAgdXNlRWZmZWN0KCgpID0+IHtcXG4gICAgY29uc29sZS5sb2coYFVzaW5nIGRhcmsgbW9kZT8gJHtkYXJrTW9kZX1gKVxcbiAgfSwgW2RhcmtNb2RlXSkgLy8gUnVuIGV2ZXJ5IHRpbWUgYGRhcmtNb2RlYCBjaGFuZ2VzXFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldERhcmtNb2RlKCFkYXJrTW9kZSl9PlxcbiAgICAgICAgICB7ZGFya01vZGUgPyAnTGlnaHQgaXQgdXAhJyA6ICdUdXJuIHRoZSBsaWdodCBvZmYhJ31cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuT3BlbiB5b3VyIGRldmVsb3BlciBjb25zb2xlLCBldmVyeSB0aW1lIHlvdSBzd2l0Y2ggYmV0d2VlbiBsaWdodCBhbmQgZGFyayBtb2RlLCB5b3Ugc2hvdWxkXFxuc2VlIGxvZ3Mgc3VjaCBhczpcXG5cXG5gYGB0ZXh0XFxuVXNpbmcgZGFyayBtb2RlPyBmYWxzZVxcblVzaW5nIGRhcmsgbW9kZT8gdHJ1ZVxcblVzaW5nIGRhcmsgbW9kZT8gZmFsc2VcXG5gYGBcXG5cXG5HcmVhdCwgdGhhdCBtZWFucyBgdXNlRWZmZWN0YCBpcyB3b3JraW5nIGFzIGV4cGVjdGVkLiBBbHRob3VnaCwgaXMgeW91IHJlZnJlc2ggdGhlIHBhZ2VcXG5pdCBrZWVwcyBmYWxsaW5nIGJhY2sgdG8gdGhlIGxpZ2h0IHRoZW1lLlxcblxcbjxiciAvPlxcblxcbkxldCdzIHVzZSBgbG9jYWxTdG9yYWdlYCB0byBmaXggdGhhdDpcXG5cXG5gYGBqczotMTIsMTNcXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xcbmltcG9ydCB7IFRoZW1lUHJvdmlkZXIgfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cydcXG5cXG5pbXBvcnQgeyBHbG9iYWxTdHlsZXMgfSBmcm9tICcuLi9zdHlsZXMvZ2xvYmFsJ1xcbmltcG9ydCB7IGxpZ2h0VGhlbWUsIGRhcmtUaGVtZSB9IGZyb20gJy4uL3N0eWxlcy90aGVtZXMnXFxuXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUodHJ1ZSlcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGNvbnNvbGUubG9nKGBVc2luZyBkYXJrIG1vZGU/ICR7ZGFya01vZGV9YClcXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0RBUktfTU9ERScsIGRhcmtNb2RlKVxcbiAgfSwgW2RhcmtNb2RlXSkgLy8gUnVuIGV2ZXJ5IHRpbWUgYGRhcmtNb2RlYCBjaGFuZ2VzXFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldERhcmtNb2RlKCFkYXJrTW9kZSl9PlxcbiAgICAgICAgICB7ZGFya01vZGUgPyAnTGlnaHQgaXQgdXAhJyA6ICdUdXJuIHRoZSBsaWdodCBvZmYhJ31cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuWW91IGNhbiBjaGVjayBpZiB0aGlzIGlzIHdvcmtpbmcgYXMgZXhwZWN0ZWQgaW4gdGhlIGRldmVsb3BlciB0b29scyBjb25zb2xlLFxcbnVuZGVyICoqQXBwbGljYXRpb24g4oaSIExvY2FsIFN0b3JhZ2Ug4oaSIGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCoqLCB5b3Ugc2hvdWxkIHNlZTpcXG5cXG58IEtleSAgICAgICAgfCBWYWx1ZSB8XFxufCAtLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLSB8XFxufCBgREFSS19NT0RFYCAgICAgIHwgYHRydWVgIG9yIGBmYWxzZWAgfFxcblxcbjxiciAvPlxcblxcbk9uY2UgYWdhaW4sIG9uIHJlZnJlc2ggaXQncyBzdGlsbCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxpZ2h0IHRoZW1lLCB0byBmaXggdGhhdCB3ZVxcbm5lZWQgdG8gbWFrZSBhIHNtYWxsIGNoYW5nZSwgd2UgbmVlZCB0byBnZXQgdGhlIHZhbHVlIGZyb20gYGxvY2FsU3RvcmFnZWAgYW5kXFxuc2V0IGFzIG91ciBkZWZhdWx0IGBkYXJrTW9kZWAgc3RhdGU6XFxuXFxuYGBganM6IS05LDExLTE1XFxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcXG5pbXBvcnQgeyBUaGVtZVByb3ZpZGVyIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnXFxuXFxuaW1wb3J0IHsgR2xvYmFsU3R5bGVzIH0gZnJvbSAnLi4vc3R5bGVzL2dsb2JhbCdcXG5pbXBvcnQgeyBsaWdodFRoZW1lLCBkYXJrVGhlbWUgfSBmcm9tICcuLi9zdHlsZXMvdGhlbWVzJ1xcblxcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIC8vIFVzZSB0aGUgc3RhdGUgdG8gZGV0ZXJtaW5lIGRhcmtNb2RlXFxuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKClcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGNvbnN0IGRhcmtNb2RlVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnREFSS19NT0RFJylcXG4gICAgLy8gbG9jYWxTdG9yYWdlIHJldHVybnMgYSBzdHJpbmcsIG5vdCBhIGJvb2xlYW5cXG4gICAgc2V0RGFya01vZGUoZGFya01vZGVWYWx1ZSA9PT0gJ3RydWUnKVxcbiAgfSwgW10pXFxuXFxuICB1c2VFZmZlY3QoKCkgPT4ge1xcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnREFSS19NT0RFJywgZGFya01vZGUpXFxuICB9LCBbZGFya01vZGVdKSAvLyBSdW4gZXZlcnkgdGltZSBgZGFya01vZGVgIGNoYW5nZXNcXG5cXG4gIHJldHVybiAoXFxuICAgIC8vIFRoaXMgd2lsbCBwYXNzIGB0aGVtZWAgZnJvbSBgVGhlbWVQcm92aWRlcmAgYXMgYSBwcm9wIGludG8gYEdsb2JhbFN0eWxlc2BcXG4gICAgPFRoZW1lUHJvdmlkZXIgdGhlbWU9e2RhcmtNb2RlID8gZGFya1RoZW1lIDogbGlnaHRUaGVtZX0+XFxuICAgICAgPGRpdj5cXG4gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldERhcmtNb2RlKCFkYXJrTW9kZSl9PlxcbiAgICAgICAgICB7ZGFya01vZGUgPyAnTGlnaHQgaXQgdXAhJyA6ICdUdXJuIHRoZSBsaWdodCBvZmYhJ31cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuV2UgY291bGQgaGF2ZSBnb3QgdGhlIGBsb2NhbFN0b3JhZ2VgIHZhbHVlIGJlZm9yZSBzZXR0aW5nIHRoZSBzdGF0ZSwgYnV0IGBsb2NhbFN0b3JhZ2VgXFxuaXMgc3RpbGwgbm90IGF2YWlsYWJsZSBiZWNhdXNlIGl0J3Mgbm90IHBhcnQgb2YgTmV4dEpTLCBzbyB0aGlzIGlzIGEgbmljZSB3b3JrLWFyb3VuZC5cXG5cXG4tLS1cXG5cXG4jIyBXaGF0IHRoZSBmbGFzaD9cXG5cXG5Zb3UgbWlnaHQgaGF2ZSBub3RpY2VkIHRoYXQgd2hlbiByZWxvYWRpbmcgeW91ciBhcHBsaWNhdGlvbiB3aGlsZSBpbiBkYXJrIG1vZGUsXFxudGhlIHBhZ2Uga2luZCBvZiBfZmxhc2hlc18gYmV0d2VlbiBsaWdodCBhbmQgZGFyayBtb2RlLiBXZWxsLCB3ZSBhbHNvIGNhbiB1c2UgYHVzZUVmZmVjdGBcXG5hcyBhIGdvb2Qgd29yay1hcm91bmQgdG8gcHJldmVudCB0aGF0LCBsZXQncyBzZXQgYW5vdGhlciBzdGF0ZSDigJMgYG1vdW50ZWRgOlxcblxcbmBgYGpzOjYsMTItMTNcXG4vLyAuLi5cXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICAvLyBVc2UgdGhlIHN0YXRlIHRvIGRldGVybWluZSBkYXJrTW9kZVxcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSgpXFxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSlcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGNvbnN0IGRhcmtNb2RlVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnREFSS19NT0RFJylcXG4gICAgLy8gbG9jYWxTdG9yYWdlIHJldHVybnMgYSBzdHJpbmcsIG5vdCBhIGJvb2xlYW5cXG4gICAgc2V0RGFya01vZGUoZGFya01vZGVWYWx1ZSA9PT0gJ3RydWUnKVxcbiAgICAvLyBTZXQgbW91bnRlZCB0byBgdHJ1ZWAgb25seSBhZnRlciBzZXR0aW5nIHRoZSBgZGFya01vZGVgIHN0YXRlXFxuICAgIHNldE1vdW50ZWQodHJ1ZSlcXG4gIH0sIFtdKVxcblxcbiAgLy8gLi4uXFxufVxcbmBgYFxcblxcbkFscmlnaHQsIG5vdyB3ZSBjYW4gc2ltcGx5IHJlbmRlciBhbiBlbXB0eSBgPGRpdiAvPmAgYmVmb3JlIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCxcXG50aGlzIHdpbGwgcHJldmVudCB0aGUgY29tcG9uZW50IHRvIHJlbmRlciBvdXIgc3R5bGVzLCBgVGhlbWVQcm92aWRlcmAgZXRjIGJlZm9yZSB3ZSBzZXQgdGhlXFxuYGRhcmtNb2RlYCBzdGF0ZTpcXG5cXG5gYGBqczoyNFxcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXFxuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJ1xcblxcbmltcG9ydCB7IEdsb2JhbFN0eWxlcyB9IGZyb20gJy4uL3N0eWxlcy9nbG9iYWwnXFxuaW1wb3J0IHsgbGlnaHRUaGVtZSwgZGFya1RoZW1lIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lcydcXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICAvLyBVc2UgdGhlIHN0YXRlIHRvIGRldGVybWluZSBkYXJrTW9kZVxcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSgpXFxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSlcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGNvbnN0IGRhcmtNb2RlVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnREFSS19NT0RFJylcXG4gICAgLy8gbG9jYWxTdG9yYWdlIHJldHVybnMgYSBzdHJpbmcsIG5vdCBhIGJvb2xlYW5cXG4gICAgc2V0RGFya01vZGUoZGFya01vZGVWYWx1ZSA9PT0gJ3RydWUnKVxcbiAgICAvLyBTZXQgbW91bnRlZCB0byBgdHJ1ZWAgb25seSBhZnRlciBzZXR0aW5nIHRoZSBgZGFya01vZGVgIHN0YXRlXFxuICAgIHNldE1vdW50ZWQodHJ1ZSlcXG4gIH0sIFtdKVxcblxcbiAgdXNlRWZmZWN0KCgpID0+IHtcXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0RBUktfTU9ERScsIGRhcmtNb2RlKVxcbiAgfSwgW2RhcmtNb2RlXSkgLy8gUnVuIGV2ZXJ5IHRpbWUgYGRhcmtNb2RlYCBjaGFuZ2VzXFxuXFxuICBpZiAoIW1vdW50ZWQpIHJldHVybiA8ZGl2IC8+XFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXREYXJrTW9kZSghZGFya01vZGUpfT5cXG4gICAgICAgICAge2RhcmtNb2RlID8gJ0xpZ2h0IGl0IHVwIScgOiAnVHVybiB0aGUgbGlnaHQgb2ZmISd9XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8R2xvYmFsU3R5bGVzIC8+XFxuICAgICAge2NoaWxkcmVufVxcbiAgICA8L1RoZW1lUHJvdmlkZXI+XFxuICApXFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IExheW91dFxcbmBgYFxcblxcbklmIHlvdSByZWxvYWQgeW91ciBhcHBsaWNhdGlvbiwgdGhlIF9mbGFzaF8gYmV0d2VlbiBsaWdodCBhbmQgZGFyayBtb2RlIHNob3VsZCBiZSBnb25lLlxcblxcbi0tLVxcblxcbiMjIFNvdXJjZSBDb2RlXFxuXFxuWW91IGNhbiBmaW5kIHRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIHR1dG9yaWFsIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vdGVsbW9nb25jYWx2ZXMvbmV4dGpzLW1hcmtkb3duLWJsb2cpLFxcbmRvbid0IGZvcmdldCBpdCdzIHVuZGVyIHRoZSBicmFuY2ggYGRhcmstbW9kZWAuXFxuXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./writings/dark-mode-enabled.md\n");

/***/ })

};;