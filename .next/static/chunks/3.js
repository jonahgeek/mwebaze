(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[3],{

/***/ "./writings/dark-mode-enabled.md":
/*!***************************************!*\
  !*** ./writings/dark-mode-enabled.md ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"---\\ntitle: \\\"Enabled dark mode with styled-components\\\"\\ndate: \\\"2020-01-08\\\"\\nauthor:\\n  twitter: \\\"telmo\\\"\\n  name: \\\"Telmo Goncalves\\\"\\n---\\n\\nAfter creating this blog, I thought it would be good to be part of all\\nthe **Dark Mode** hype. And since I've never done it, I tried it out.\\n\\n![](https://img.onl/ksEPSi)\\n> Outdated version of my blog\\n\\nSince I'd never really worked with NextJS aside from building this blog,\\nI had to do some research before getting my hands dirty.\\n\\n<br />\\n\\nFor this tutorial, I'll continue using the code from [this post](/writings/nextjs-blog-in-less-than-1-hour),\\nalthough I'll leave the changes for this tutorial in a branch called `dark-mode`.\\n\\n---\\n\\n## All right, let's get started\\n\\nFor this to happen we'll be using `styled-components`, if you're not familiar with it,\\nI would suggest you take a quick look into [their documentation](https://www.styled-components.com/docs/basics#getting-started).\\n\\n<br />\\n\\nIn the root of your projects let us create a `styles` folder and a `themes.js` file:\\n\\n```bash\\nmkdir styles && touch styles/themes.js\\n```\\n\\nAll right, we need a `light` and a `dark` theme, for that we can simply create 2 objects,\\none for each theme:\\n\\n```js\\nexport const lightTheme = {\\n  body: '#FFFFFF',\\n  text: '#363537',\\n}\\n\\nexport const darkTheme = {\\n  body: '#101010',\\n  text: '#FAFAFA',\\n}\\n\\n```\\n\\nDon't worry about this for now, we'll be using it later.\\n\\n<br />\\n\\nWhat I've done was creating a `Layout` wrapper that contains my global styles, theme styles and so forth.\\nBut before that let's define our global styles:\\n\\n```bash\\ntouch styles/global.js\\n```\\n\\nInside `global.js` we'll be using `styled-components`, so let's take care of install it:\\n\\n```bash\\nnpm install styled-components --save\\n```\\n\\n<br />\\n\\nLet's start with something simple such as, background and text color:\\n\\n```js\\nimport { createGlobalStyle } from 'styled-components';\\n\\n// the `theme` object is comming from our ./themes.js file\\nexport const GlobalStyles = createGlobalStyle`\\n  body {\\n    background-color: ${({ theme }) => theme.body};\\n    color: ${({ theme }) => theme.text}\\n  }\\n`\\n```\\n\\n<br />\\n\\nCool, we should be done with this, let's look into implement the themes.\\n\\n---\\n\\n## Layout and Theme Switch\\n\\nI've mentioned that I used a `Layout` wrapper to take care of styles, themes, and so forth. Let's\\ncreate that wrapper:\\n\\n```bash\\nmkdir components && touch components/Layout.js\\n```\\n\\n<br />\\n\\nPaste the following into `Layout.js`:\\n\\n```js\\nimport React from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\n// Default dark mode to true for now\\nconst darkMode = true\\n\\nfunction Layout({ children }) {\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nWe should be ready to wrap our pages with `Layout`, if you look at the codebase\\nI've provided at the beginning of this tutorial you should see a file `/pages/index.js`,\\non that file change the following lines:\\n\\n```js:3,7,9\\nimport React from 'react'\\n\\nimport Layout from '../components/Layout'\\n\\nexport default function Index(props) {\\n  return (\\n    <Layout>\\n      ‚úçÔ∏è My blog about {props.blogCategory}\\n    </Layout>\\n  )\\n}\\n\\nIndex.getInitialProps = () => {\\n  return {\\n    blogCategory: 'ReactJS'\\n  }\\n}\\n```\\n\\nRun the following commands and access your application at `http://localhost:3000`:\\n\\n```bash\\nnpm install && npm run dev\\n```\\n\\nYou should see the background turned dark and the text white ü•≥\\n\\n<br />\\n\\n### Let there be light\\n\\nLet's change the `Layout` wrapper to allow us to switch between dark and light mode. Go\\nto the `components/Layout.js` file and let's make some changes:\\n\\n```js:!-1,-7-8,11-12\\nimport React, { useState } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\n// Default dark mode to true for now\\nconst darkMode = true\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nIf you refresh the page, you should see the same behaviour: dark background, white text.\\n\\n<br />\\n\\nLet's make a quick change to check if our **Light** theme is working as well, change\\nour `darkMode` state from `true` to `false`:\\n\\n```js:!-3\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(false)\\n\\n  // ...\\n}\\n```\\n\\nRefresh the page; you should see the original theme: white background, dark text üëå\\n\\n<br />\\n\\n#### The Switch\\n\\nWe'll be using the `setDarkMode` method from the previous code, we'll create a\\n`<button>` with an `onClick` prop:\\n\\n```js:14-18\\nimport React, { useState } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nSo, what are we doing with `onClick={() => setDarkMode(!darkMode)}`, we're setting\\nthe `darkMode` state by using the `! (not)` operator, which inverts the boolean expression:\\n\\n```js\\nlet darkMode = true\\n\\ndarkMode = !darkMode // false\\ndarkMode = !darkMode // true\\n```\\n\\n---\\n\\n## Persistence\\n\\nYou should notice that every time you refresh your application and theme falls back to the light theme,\\nwell, let's deal with that.\\n\\n<br />\\n\\nFor that we'll take advantage of `localStorage` and React Hooks `useEffect` method. Let's take a look:\\n\\n```js:!-1,11-13\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  useEffect(() => {\\n    console.log(`Using dark mode? ${darkMode}`)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nOpen your developer console, every time you switch between light and dark mode, you should\\nsee logs such as:\\n\\n```text\\nUsing dark mode? false\\nUsing dark mode? true\\nUsing dark mode? false\\n```\\n\\nGreat, that means `useEffect` is working as expected. Although, is you refresh the page\\nit keeps falling back to the light theme.\\n\\n<br />\\n\\nLet's use `localStorage` to fix that:\\n\\n```js:-12,13\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState(true)\\n\\n  useEffect(() => {\\n    console.log(`Using dark mode? ${darkMode}`)\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n        <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nYou can check if this is working as expected in the developer tools console,\\nunder **Application ‚Üí Local Storage ‚Üí http://localhost:3000**, you should see:\\n\\n| Key        | Value |\\n| ------------- | ------------- |\\n| `DARK_MODE`      | `true` or `false` |\\n\\n<br />\\n\\nOnce again, on refresh it's still falling back to the light theme, to fix that we\\nneed to make a small change, we need to get the value from `localStorage` and\\nset as our default `darkMode` state:\\n\\n```js:!-9,11-15\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n  }, [])\\n\\n  useEffect(() => {\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n         <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nWe could have got the `localStorage` value before setting the state, but `localStorage`\\nis still not available because it's not part of NextJS, so this is a nice work-around.\\n\\n---\\n\\n## What the flash?\\n\\nYou might have noticed that when reloading your application while in dark mode,\\nthe page kind of _flashes_ between light and dark mode. Well, we also can use `useEffect`\\nas a good work-around to prevent that, let's set another state ‚Äì `mounted`:\\n\\n```js:6,12-13\\n// ...\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n  const [mounted, setMounted] = useState(false)\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n    // Set mounted to `true` only after setting the `darkMode` state\\n    setMounted(true)\\n  }, [])\\n\\n  // ...\\n}\\n```\\n\\nAlright, now we can simply render an empty `<div />` before the component has been mounted,\\nthis will prevent the component to render our styles, `ThemeProvider` etc before we set the\\n`darkMode` state:\\n\\n```js:24\\nimport React, { useState, useEffect } from 'react'\\nimport { ThemeProvider } from 'styled-components'\\n\\nimport { GlobalStyles } from '../styles/global'\\nimport { lightTheme, darkTheme } from '../styles/themes'\\n\\nfunction Layout({ children }) {\\n  // Use the state to determine darkMode\\n  const [darkMode, setDarkMode] = useState()\\n  const [mounted, setMounted] = useState(false)\\n\\n  useEffect(() => {\\n    const darkModeValue = localStorage.getItem('DARK_MODE')\\n    // localStorage returns a string, not a boolean\\n    setDarkMode(darkModeValue === 'true')\\n    // Set mounted to `true` only after setting the `darkMode` state\\n    setMounted(true)\\n  }, [])\\n\\n  useEffect(() => {\\n    localStorage.setItem('DARK_MODE', darkMode)\\n  }, [darkMode]) // Run every time `darkMode` changes\\n\\n  if (!mounted) return <div />\\n\\n  return (\\n    // This will pass `theme` from `ThemeProvider` as a prop into `GlobalStyles`\\n    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>\\n      <div>\\n         <button onClick={() => setDarkMode(!darkMode)}>\\n          {darkMode ? 'Light it up!' : 'Turn the light off!'}\\n        </button>\\n      </div>\\n\\n      <GlobalStyles />\\n      {children}\\n    </ThemeProvider>\\n  )\\n}\\n\\nexport default Layout\\n```\\n\\nIf you reload your application, the _flash_ between light and dark mode should be gone.\\n\\n---\\n\\n## Source Code\\n\\nYou can find the source code of this tutorial [here](https://github.com/telmogoncalves/nextjs-markdown-blog),\\ndon't forget it's under the branch `dark-mode`.\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vd3JpdGluZ3MvZGFyay1tb2RlLWVuYWJsZWQubWQ/MDUxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLHl5Q0FBMHVDLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDJnQkFBMmdCLG9CQUFvQiwwQkFBMEIsd0hBQXdILDBCQUEwQixFQUFFLFFBQVEsaUJBQWlCLGVBQWUsRUFBRSxRQUFRLGdCQUFnQixLQUFLLCtaQUErWixnQkFBZ0IscUNBQXFDLGVBQWUsa0NBQWtDLHdCQUF3Qiw0R0FBNEcsV0FBVyxHQUFHLDBIQUEwSCxrQ0FBa0Msa0NBQWtDLFNBQVMsOEJBQThCLHNYQUFzWCxvREFBb0QsbUJBQW1CLHVCQUF1QixtQ0FBbUMsWUFBWSxrQ0FBa0MsR0FBRyxtYkFBbWIsV0FBVyx1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNEdBQTRHLFdBQVcsR0FBRyx3TkFBd04sa0NBQWtDLGtDQUFrQyxTQUFTLDhCQUE4QiwwU0FBMFMsV0FBVyxHQUFHLDRHQUE0RywwQkFBMEIscVBBQXFQLFdBQVcsdUJBQXVCLGdCQUFnQixxQ0FBcUMsZUFBZSxrQ0FBa0Msd0JBQXdCLDZDQUE2QyxXQUFXLEdBQUcsd05BQXdOLGtDQUFrQyx5Q0FBeUMsNkJBQTZCLGNBQWMsa0RBQWtELGtFQUFrRSxTQUFTLDhCQUE4Qix1RUFBdUUsNkJBQTZCLHdnQkFBd2dCLHNCQUFzQix1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNkNBQTZDLFdBQVcsR0FBRyxtSEFBbUgsc0NBQXNDLFNBQVMsT0FBTyw4S0FBOEssa0NBQWtDLHlDQUF5Qyw2QkFBNkIsY0FBYyxrREFBa0Qsa0VBQWtFLFNBQVMsOEJBQThCLGdjQUFnYyxzQkFBc0IsdUJBQXVCLGdCQUFnQixxQ0FBcUMsZUFBZSxrQ0FBa0Msd0JBQXdCLDZDQUE2QyxXQUFXLEdBQUcsbUhBQW1ILHNDQUFzQyxTQUFTLHdEQUF3RCw4S0FBOEssa0NBQWtDLHlDQUF5Qyw2QkFBNkIsY0FBYyxrREFBa0Qsa0VBQWtFLFNBQVMsOEJBQThCLDZoQkFBNmhCLHNCQUFzQix1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNkNBQTZDLFdBQVcsR0FBRywrR0FBK0csa0tBQWtLLDRCQUE0QixzREFBc0QsOEtBQThLLGtDQUFrQywwQ0FBMEMsNkJBQTZCLGNBQWMsa0RBQWtELG9FQUFvRSxTQUFTLDhCQUE4Qix1aEJBQXVoQixXQUFXLEdBQUcsZ0tBQWdLLDhQQUE4UCxvQkFBb0IsaVBBQWlQLHNCQUFzQix1QkFBdUIsZ0JBQWdCLHFDQUFxQyxlQUFlLGtDQUFrQyx3QkFBd0IsNkNBQTZDLFdBQVcsR0FBRyxnS0FBZ0ssOFBBQThQLDRCQUE0QixzREFBc0QsZ05BQWdOLGtDQUFrQywwQ0FBMEMsNkJBQTZCLGNBQWMsa0RBQWtELG9FQUFvRSxTQUFTLDhCQUE4Qix1VEFBdVQiLCJmaWxlIjoiLi93cml0aW5ncy9kYXJrLW1vZGUtZW5hYmxlZC5tZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxudGl0bGU6IFxcXCJFbmFibGVkIGRhcmsgbW9kZSB3aXRoIHN0eWxlZC1jb21wb25lbnRzXFxcIlxcbmRhdGU6IFxcXCIyMDIwLTAxLTA4XFxcIlxcbmF1dGhvcjpcXG4gIHR3aXR0ZXI6IFxcXCJ0ZWxtb1xcXCJcXG4gIG5hbWU6IFxcXCJUZWxtbyBHb25jYWx2ZXNcXFwiXFxuLS0tXFxuXFxuQWZ0ZXIgY3JlYXRpbmcgdGhpcyBibG9nLCBJIHRob3VnaHQgaXQgd291bGQgYmUgZ29vZCB0byBiZSBwYXJ0IG9mIGFsbFxcbnRoZSAqKkRhcmsgTW9kZSoqIGh5cGUuIEFuZCBzaW5jZSBJJ3ZlIG5ldmVyIGRvbmUgaXQsIEkgdHJpZWQgaXQgb3V0LlxcblxcbiFbXShodHRwczovL2ltZy5vbmwva3NFUFNpKVxcbj4gT3V0ZGF0ZWQgdmVyc2lvbiBvZiBteSBibG9nXFxuXFxuU2luY2UgSSdkIG5ldmVyIHJlYWxseSB3b3JrZWQgd2l0aCBOZXh0SlMgYXNpZGUgZnJvbSBidWlsZGluZyB0aGlzIGJsb2csXFxuSSBoYWQgdG8gZG8gc29tZSByZXNlYXJjaCBiZWZvcmUgZ2V0dGluZyBteSBoYW5kcyBkaXJ0eS5cXG5cXG48YnIgLz5cXG5cXG5Gb3IgdGhpcyB0dXRvcmlhbCwgSSdsbCBjb250aW51ZSB1c2luZyB0aGUgY29kZSBmcm9tIFt0aGlzIHBvc3RdKC93cml0aW5ncy9uZXh0anMtYmxvZy1pbi1sZXNzLXRoYW4tMS1ob3VyKSxcXG5hbHRob3VnaCBJJ2xsIGxlYXZlIHRoZSBjaGFuZ2VzIGZvciB0aGlzIHR1dG9yaWFsIGluIGEgYnJhbmNoIGNhbGxlZCBgZGFyay1tb2RlYC5cXG5cXG4tLS1cXG5cXG4jIyBBbGwgcmlnaHQsIGxldCdzIGdldCBzdGFydGVkXFxuXFxuRm9yIHRoaXMgdG8gaGFwcGVuIHdlJ2xsIGJlIHVzaW5nIGBzdHlsZWQtY29tcG9uZW50c2AsIGlmIHlvdSdyZSBub3QgZmFtaWxpYXIgd2l0aCBpdCxcXG5JIHdvdWxkIHN1Z2dlc3QgeW91IHRha2UgYSBxdWljayBsb29rIGludG8gW3RoZWlyIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2Jhc2ljcyNnZXR0aW5nLXN0YXJ0ZWQpLlxcblxcbjxiciAvPlxcblxcbkluIHRoZSByb290IG9mIHlvdXIgcHJvamVjdHMgbGV0IHVzIGNyZWF0ZSBhIGBzdHlsZXNgIGZvbGRlciBhbmQgYSBgdGhlbWVzLmpzYCBmaWxlOlxcblxcbmBgYGJhc2hcXG5ta2RpciBzdHlsZXMgJiYgdG91Y2ggc3R5bGVzL3RoZW1lcy5qc1xcbmBgYFxcblxcbkFsbCByaWdodCwgd2UgbmVlZCBhIGBsaWdodGAgYW5kIGEgYGRhcmtgIHRoZW1lLCBmb3IgdGhhdCB3ZSBjYW4gc2ltcGx5IGNyZWF0ZSAyIG9iamVjdHMsXFxub25lIGZvciBlYWNoIHRoZW1lOlxcblxcbmBgYGpzXFxuZXhwb3J0IGNvbnN0IGxpZ2h0VGhlbWUgPSB7XFxuICBib2R5OiAnI0ZGRkZGRicsXFxuICB0ZXh0OiAnIzM2MzUzNycsXFxufVxcblxcbmV4cG9ydCBjb25zdCBkYXJrVGhlbWUgPSB7XFxuICBib2R5OiAnIzEwMTAxMCcsXFxuICB0ZXh0OiAnI0ZBRkFGQScsXFxufVxcblxcbmBgYFxcblxcbkRvbid0IHdvcnJ5IGFib3V0IHRoaXMgZm9yIG5vdywgd2UnbGwgYmUgdXNpbmcgaXQgbGF0ZXIuXFxuXFxuPGJyIC8+XFxuXFxuV2hhdCBJJ3ZlIGRvbmUgd2FzIGNyZWF0aW5nIGEgYExheW91dGAgd3JhcHBlciB0aGF0IGNvbnRhaW5zIG15IGdsb2JhbCBzdHlsZXMsIHRoZW1lIHN0eWxlcyBhbmQgc28gZm9ydGguXFxuQnV0IGJlZm9yZSB0aGF0IGxldCdzIGRlZmluZSBvdXIgZ2xvYmFsIHN0eWxlczpcXG5cXG5gYGBiYXNoXFxudG91Y2ggc3R5bGVzL2dsb2JhbC5qc1xcbmBgYFxcblxcbkluc2lkZSBgZ2xvYmFsLmpzYCB3ZSdsbCBiZSB1c2luZyBgc3R5bGVkLWNvbXBvbmVudHNgLCBzbyBsZXQncyB0YWtlIGNhcmUgb2YgaW5zdGFsbCBpdDpcXG5cXG5gYGBiYXNoXFxubnBtIGluc3RhbGwgc3R5bGVkLWNvbXBvbmVudHMgLS1zYXZlXFxuYGBgXFxuXFxuPGJyIC8+XFxuXFxuTGV0J3Mgc3RhcnQgd2l0aCBzb21ldGhpbmcgc2ltcGxlIHN1Y2ggYXMsIGJhY2tncm91bmQgYW5kIHRleHQgY29sb3I6XFxuXFxuYGBganNcXG5pbXBvcnQgeyBjcmVhdGVHbG9iYWxTdHlsZSB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcXG5cXG4vLyB0aGUgYHRoZW1lYCBvYmplY3QgaXMgY29tbWluZyBmcm9tIG91ciAuL3RoZW1lcy5qcyBmaWxlXFxuZXhwb3J0IGNvbnN0IEdsb2JhbFN0eWxlcyA9IGNyZWF0ZUdsb2JhbFN0eWxlYFxcbiAgYm9keSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuYm9keX07XFxuICAgIGNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnRleHR9XFxuICB9XFxuYFxcbmBgYFxcblxcbjxiciAvPlxcblxcbkNvb2wsIHdlIHNob3VsZCBiZSBkb25lIHdpdGggdGhpcywgbGV0J3MgbG9vayBpbnRvIGltcGxlbWVudCB0aGUgdGhlbWVzLlxcblxcbi0tLVxcblxcbiMjIExheW91dCBhbmQgVGhlbWUgU3dpdGNoXFxuXFxuSSd2ZSBtZW50aW9uZWQgdGhhdCBJIHVzZWQgYSBgTGF5b3V0YCB3cmFwcGVyIHRvIHRha2UgY2FyZSBvZiBzdHlsZXMsIHRoZW1lcywgYW5kIHNvIGZvcnRoLiBMZXQnc1xcbmNyZWF0ZSB0aGF0IHdyYXBwZXI6XFxuXFxuYGBgYmFzaFxcbm1rZGlyIGNvbXBvbmVudHMgJiYgdG91Y2ggY29tcG9uZW50cy9MYXlvdXQuanNcXG5gYGBcXG5cXG48YnIgLz5cXG5cXG5QYXN0ZSB0aGUgZm9sbG93aW5nIGludG8gYExheW91dC5qc2A6XFxuXFxuYGBganNcXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXFxuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJ1xcblxcbmltcG9ydCB7IEdsb2JhbFN0eWxlcyB9IGZyb20gJy4uL3N0eWxlcy9nbG9iYWwnXFxuaW1wb3J0IHsgbGlnaHRUaGVtZSwgZGFya1RoZW1lIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lcydcXG5cXG4vLyBEZWZhdWx0IGRhcmsgbW9kZSB0byB0cnVlIGZvciBub3dcXG5jb25zdCBkYXJrTW9kZSA9IHRydWVcXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuV2Ugc2hvdWxkIGJlIHJlYWR5IHRvIHdyYXAgb3VyIHBhZ2VzIHdpdGggYExheW91dGAsIGlmIHlvdSBsb29rIGF0IHRoZSBjb2RlYmFzZVxcbkkndmUgcHJvdmlkZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIHR1dG9yaWFsIHlvdSBzaG91bGQgc2VlIGEgZmlsZSBgL3BhZ2VzL2luZGV4LmpzYCxcXG5vbiB0aGF0IGZpbGUgY2hhbmdlIHRoZSBmb2xsb3dpbmcgbGluZXM6XFxuXFxuYGBganM6Myw3LDlcXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXFxuXFxuaW1wb3J0IExheW91dCBmcm9tICcuLi9jb21wb25lbnRzL0xheW91dCdcXG5cXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmRleChwcm9wcykge1xcbiAgcmV0dXJuIChcXG4gICAgPExheW91dD5cXG4gICAgICDinI3vuI8gTXkgYmxvZyBhYm91dCB7cHJvcHMuYmxvZ0NhdGVnb3J5fVxcbiAgICA8L0xheW91dD5cXG4gIClcXG59XFxuXFxuSW5kZXguZ2V0SW5pdGlhbFByb3BzID0gKCkgPT4ge1xcbiAgcmV0dXJuIHtcXG4gICAgYmxvZ0NhdGVnb3J5OiAnUmVhY3RKUydcXG4gIH1cXG59XFxuYGBgXFxuXFxuUnVuIHRoZSBmb2xsb3dpbmcgY29tbWFuZHMgYW5kIGFjY2VzcyB5b3VyIGFwcGxpY2F0aW9uIGF0IGBodHRwOi8vbG9jYWxob3N0OjMwMDBgOlxcblxcbmBgYGJhc2hcXG5ucG0gaW5zdGFsbCAmJiBucG0gcnVuIGRldlxcbmBgYFxcblxcbllvdSBzaG91bGQgc2VlIHRoZSBiYWNrZ3JvdW5kIHR1cm5lZCBkYXJrIGFuZCB0aGUgdGV4dCB3aGl0ZSDwn6WzXFxuXFxuPGJyIC8+XFxuXFxuIyMjIExldCB0aGVyZSBiZSBsaWdodFxcblxcbkxldCdzIGNoYW5nZSB0aGUgYExheW91dGAgd3JhcHBlciB0byBhbGxvdyB1cyB0byBzd2l0Y2ggYmV0d2VlbiBkYXJrIGFuZCBsaWdodCBtb2RlLiBHb1xcbnRvIHRoZSBgY29tcG9uZW50cy9MYXlvdXQuanNgIGZpbGUgYW5kIGxldCdzIG1ha2Ugc29tZSBjaGFuZ2VzOlxcblxcbmBgYGpzOiEtMSwtNy04LDExLTEyXFxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXFxuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJ1xcblxcbmltcG9ydCB7IEdsb2JhbFN0eWxlcyB9IGZyb20gJy4uL3N0eWxlcy9nbG9iYWwnXFxuaW1wb3J0IHsgbGlnaHRUaGVtZSwgZGFya1RoZW1lIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lcydcXG5cXG4vLyBEZWZhdWx0IGRhcmsgbW9kZSB0byB0cnVlIGZvciBub3dcXG5jb25zdCBkYXJrTW9kZSA9IHRydWVcXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICAvLyBVc2UgdGhlIHN0YXRlIHRvIGRldGVybWluZSBkYXJrTW9kZVxcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSh0cnVlKVxcblxcbiAgcmV0dXJuIChcXG4gICAgLy8gVGhpcyB3aWxsIHBhc3MgYHRoZW1lYCBmcm9tIGBUaGVtZVByb3ZpZGVyYCBhcyBhIHByb3AgaW50byBgR2xvYmFsU3R5bGVzYFxcbiAgICA8VGhlbWVQcm92aWRlciB0aGVtZT17ZGFya01vZGUgPyBkYXJrVGhlbWUgOiBsaWdodFRoZW1lfT5cXG4gICAgICA8R2xvYmFsU3R5bGVzIC8+XFxuICAgICAge2NoaWxkcmVufVxcbiAgICA8L1RoZW1lUHJvdmlkZXI+XFxuICApXFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IExheW91dFxcbmBgYFxcblxcbklmIHlvdSByZWZyZXNoIHRoZSBwYWdlLCB5b3Ugc2hvdWxkIHNlZSB0aGUgc2FtZSBiZWhhdmlvdXI6IGRhcmsgYmFja2dyb3VuZCwgd2hpdGUgdGV4dC5cXG5cXG48YnIgLz5cXG5cXG5MZXQncyBtYWtlIGEgcXVpY2sgY2hhbmdlIHRvIGNoZWNrIGlmIG91ciAqKkxpZ2h0KiogdGhlbWUgaXMgd29ya2luZyBhcyB3ZWxsLCBjaGFuZ2VcXG5vdXIgYGRhcmtNb2RlYCBzdGF0ZSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgOlxcblxcbmBgYGpzOiEtM1xcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIC8vIFVzZSB0aGUgc3RhdGUgdG8gZGV0ZXJtaW5lIGRhcmtNb2RlXFxuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKVxcblxcbiAgLy8gLi4uXFxufVxcbmBgYFxcblxcblJlZnJlc2ggdGhlIHBhZ2U7IHlvdSBzaG91bGQgc2VlIHRoZSBvcmlnaW5hbCB0aGVtZTogd2hpdGUgYmFja2dyb3VuZCwgZGFyayB0ZXh0IPCfkYxcXG5cXG48YnIgLz5cXG5cXG4jIyMjIFRoZSBTd2l0Y2hcXG5cXG5XZSdsbCBiZSB1c2luZyB0aGUgYHNldERhcmtNb2RlYCBtZXRob2QgZnJvbSB0aGUgcHJldmlvdXMgY29kZSwgd2UnbGwgY3JlYXRlIGFcXG5gPGJ1dHRvbj5gIHdpdGggYW4gYG9uQ2xpY2tgIHByb3A6XFxuXFxuYGBganM6MTQtMThcXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcXG5pbXBvcnQgeyBUaGVtZVByb3ZpZGVyIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnXFxuXFxuaW1wb3J0IHsgR2xvYmFsU3R5bGVzIH0gZnJvbSAnLi4vc3R5bGVzL2dsb2JhbCdcXG5pbXBvcnQgeyBsaWdodFRoZW1lLCBkYXJrVGhlbWUgfSBmcm9tICcuLi9zdHlsZXMvdGhlbWVzJ1xcblxcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIC8vIFVzZSB0aGUgc3RhdGUgdG8gZGV0ZXJtaW5lIGRhcmtNb2RlXFxuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKHRydWUpXFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldERhcmtNb2RlKCFkYXJrTW9kZSl9PlxcbiAgICAgICAgICB7ZGFya01vZGUgPyAnTGlnaHQgaXQgdXAhJyA6ICdUdXJuIHRoZSBsaWdodCBvZmYhJ31cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxHbG9iYWxTdHlsZXMgLz5cXG4gICAgICB7Y2hpbGRyZW59XFxuICAgIDwvVGhlbWVQcm92aWRlcj5cXG4gIClcXG59XFxuXFxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XFxuYGBgXFxuXFxuU28sIHdoYXQgYXJlIHdlIGRvaW5nIHdpdGggYG9uQ2xpY2s9eygpID0+IHNldERhcmtNb2RlKCFkYXJrTW9kZSl9YCwgd2UncmUgc2V0dGluZ1xcbnRoZSBgZGFya01vZGVgIHN0YXRlIGJ5IHVzaW5nIHRoZSBgISAobm90KWAgb3BlcmF0b3IsIHdoaWNoIGludmVydHMgdGhlIGJvb2xlYW4gZXhwcmVzc2lvbjpcXG5cXG5gYGBqc1xcbmxldCBkYXJrTW9kZSA9IHRydWVcXG5cXG5kYXJrTW9kZSA9ICFkYXJrTW9kZSAvLyBmYWxzZVxcbmRhcmtNb2RlID0gIWRhcmtNb2RlIC8vIHRydWVcXG5gYGBcXG5cXG4tLS1cXG5cXG4jIyBQZXJzaXN0ZW5jZVxcblxcbllvdSBzaG91bGQgbm90aWNlIHRoYXQgZXZlcnkgdGltZSB5b3UgcmVmcmVzaCB5b3VyIGFwcGxpY2F0aW9uIGFuZCB0aGVtZSBmYWxscyBiYWNrIHRvIHRoZSBsaWdodCB0aGVtZSxcXG53ZWxsLCBsZXQncyBkZWFsIHdpdGggdGhhdC5cXG5cXG48YnIgLz5cXG5cXG5Gb3IgdGhhdCB3ZSdsbCB0YWtlIGFkdmFudGFnZSBvZiBgbG9jYWxTdG9yYWdlYCBhbmQgUmVhY3QgSG9va3MgYHVzZUVmZmVjdGAgbWV0aG9kLiBMZXQncyB0YWtlIGEgbG9vazpcXG5cXG5gYGBqczohLTEsMTEtMTNcXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xcbmltcG9ydCB7IFRoZW1lUHJvdmlkZXIgfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cydcXG5cXG5pbXBvcnQgeyBHbG9iYWxTdHlsZXMgfSBmcm9tICcuLi9zdHlsZXMvZ2xvYmFsJ1xcbmltcG9ydCB7IGxpZ2h0VGhlbWUsIGRhcmtUaGVtZSB9IGZyb20gJy4uL3N0eWxlcy90aGVtZXMnXFxuXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUodHJ1ZSlcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGNvbnNvbGUubG9nKGBVc2luZyBkYXJrIG1vZGU/ICR7ZGFya01vZGV9YClcXG4gIH0sIFtkYXJrTW9kZV0pIC8vIFJ1biBldmVyeSB0aW1lIGBkYXJrTW9kZWAgY2hhbmdlc1xcblxcbiAgcmV0dXJuIChcXG4gICAgLy8gVGhpcyB3aWxsIHBhc3MgYHRoZW1lYCBmcm9tIGBUaGVtZVByb3ZpZGVyYCBhcyBhIHByb3AgaW50byBgR2xvYmFsU3R5bGVzYFxcbiAgICA8VGhlbWVQcm92aWRlciB0aGVtZT17ZGFya01vZGUgPyBkYXJrVGhlbWUgOiBsaWdodFRoZW1lfT5cXG4gICAgICA8ZGl2PlxcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXREYXJrTW9kZSghZGFya01vZGUpfT5cXG4gICAgICAgICAge2RhcmtNb2RlID8gJ0xpZ2h0IGl0IHVwIScgOiAnVHVybiB0aGUgbGlnaHQgb2ZmISd9XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8R2xvYmFsU3R5bGVzIC8+XFxuICAgICAge2NoaWxkcmVufVxcbiAgICA8L1RoZW1lUHJvdmlkZXI+XFxuICApXFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IExheW91dFxcbmBgYFxcblxcbk9wZW4geW91ciBkZXZlbG9wZXIgY29uc29sZSwgZXZlcnkgdGltZSB5b3Ugc3dpdGNoIGJldHdlZW4gbGlnaHQgYW5kIGRhcmsgbW9kZSwgeW91IHNob3VsZFxcbnNlZSBsb2dzIHN1Y2ggYXM6XFxuXFxuYGBgdGV4dFxcblVzaW5nIGRhcmsgbW9kZT8gZmFsc2VcXG5Vc2luZyBkYXJrIG1vZGU/IHRydWVcXG5Vc2luZyBkYXJrIG1vZGU/IGZhbHNlXFxuYGBgXFxuXFxuR3JlYXQsIHRoYXQgbWVhbnMgYHVzZUVmZmVjdGAgaXMgd29ya2luZyBhcyBleHBlY3RlZC4gQWx0aG91Z2gsIGlzIHlvdSByZWZyZXNoIHRoZSBwYWdlXFxuaXQga2VlcHMgZmFsbGluZyBiYWNrIHRvIHRoZSBsaWdodCB0aGVtZS5cXG5cXG48YnIgLz5cXG5cXG5MZXQncyB1c2UgYGxvY2FsU3RvcmFnZWAgdG8gZml4IHRoYXQ6XFxuXFxuYGBganM6LTEyLDEzXFxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcXG5pbXBvcnQgeyBUaGVtZVByb3ZpZGVyIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnXFxuXFxuaW1wb3J0IHsgR2xvYmFsU3R5bGVzIH0gZnJvbSAnLi4vc3R5bGVzL2dsb2JhbCdcXG5pbXBvcnQgeyBsaWdodFRoZW1lLCBkYXJrVGhlbWUgfSBmcm9tICcuLi9zdHlsZXMvdGhlbWVzJ1xcblxcbmZ1bmN0aW9uIExheW91dCh7IGNoaWxkcmVuIH0pIHtcXG4gIC8vIFVzZSB0aGUgc3RhdGUgdG8gZGV0ZXJtaW5lIGRhcmtNb2RlXFxuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKHRydWUpXFxuXFxuICB1c2VFZmZlY3QoKCkgPT4ge1xcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgZGFyayBtb2RlPyAke2RhcmtNb2RlfWApXFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdEQVJLX01PREUnLCBkYXJrTW9kZSlcXG4gIH0sIFtkYXJrTW9kZV0pIC8vIFJ1biBldmVyeSB0aW1lIGBkYXJrTW9kZWAgY2hhbmdlc1xcblxcbiAgcmV0dXJuIChcXG4gICAgLy8gVGhpcyB3aWxsIHBhc3MgYHRoZW1lYCBmcm9tIGBUaGVtZVByb3ZpZGVyYCBhcyBhIHByb3AgaW50byBgR2xvYmFsU3R5bGVzYFxcbiAgICA8VGhlbWVQcm92aWRlciB0aGVtZT17ZGFya01vZGUgPyBkYXJrVGhlbWUgOiBsaWdodFRoZW1lfT5cXG4gICAgICA8ZGl2PlxcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXREYXJrTW9kZSghZGFya01vZGUpfT5cXG4gICAgICAgICAge2RhcmtNb2RlID8gJ0xpZ2h0IGl0IHVwIScgOiAnVHVybiB0aGUgbGlnaHQgb2ZmISd9XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8R2xvYmFsU3R5bGVzIC8+XFxuICAgICAge2NoaWxkcmVufVxcbiAgICA8L1RoZW1lUHJvdmlkZXI+XFxuICApXFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IExheW91dFxcbmBgYFxcblxcbllvdSBjYW4gY2hlY2sgaWYgdGhpcyBpcyB3b3JraW5nIGFzIGV4cGVjdGVkIGluIHRoZSBkZXZlbG9wZXIgdG9vbHMgY29uc29sZSxcXG51bmRlciAqKkFwcGxpY2F0aW9uIOKGkiBMb2NhbCBTdG9yYWdlIOKGkiBodHRwOi8vbG9jYWxob3N0OjMwMDAqKiwgeW91IHNob3VsZCBzZWU6XFxuXFxufCBLZXkgICAgICAgIHwgVmFsdWUgfFxcbnwgLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0gfFxcbnwgYERBUktfTU9ERWAgICAgICB8IGB0cnVlYCBvciBgZmFsc2VgIHxcXG5cXG48YnIgLz5cXG5cXG5PbmNlIGFnYWluLCBvbiByZWZyZXNoIGl0J3Mgc3RpbGwgZmFsbGluZyBiYWNrIHRvIHRoZSBsaWdodCB0aGVtZSwgdG8gZml4IHRoYXQgd2VcXG5uZWVkIHRvIG1ha2UgYSBzbWFsbCBjaGFuZ2UsIHdlIG5lZWQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tIGBsb2NhbFN0b3JhZ2VgIGFuZFxcbnNldCBhcyBvdXIgZGVmYXVsdCBgZGFya01vZGVgIHN0YXRlOlxcblxcbmBgYGpzOiEtOSwxMS0xNVxcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXFxuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJ1xcblxcbmltcG9ydCB7IEdsb2JhbFN0eWxlcyB9IGZyb20gJy4uL3N0eWxlcy9nbG9iYWwnXFxuaW1wb3J0IHsgbGlnaHRUaGVtZSwgZGFya1RoZW1lIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lcydcXG5cXG5mdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XFxuICAvLyBVc2UgdGhlIHN0YXRlIHRvIGRldGVybWluZSBkYXJrTW9kZVxcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSgpXFxuXFxuICB1c2VFZmZlY3QoKCkgPT4ge1xcbiAgICBjb25zdCBkYXJrTW9kZVZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0RBUktfTU9ERScpXFxuICAgIC8vIGxvY2FsU3RvcmFnZSByZXR1cm5zIGEgc3RyaW5nLCBub3QgYSBib29sZWFuXFxuICAgIHNldERhcmtNb2RlKGRhcmtNb2RlVmFsdWUgPT09ICd0cnVlJylcXG4gIH0sIFtdKVxcblxcbiAgdXNlRWZmZWN0KCgpID0+IHtcXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0RBUktfTU9ERScsIGRhcmtNb2RlKVxcbiAgfSwgW2RhcmtNb2RlXSkgLy8gUnVuIGV2ZXJ5IHRpbWUgYGRhcmtNb2RlYCBjaGFuZ2VzXFxuXFxuICByZXR1cm4gKFxcbiAgICAvLyBUaGlzIHdpbGwgcGFzcyBgdGhlbWVgIGZyb20gYFRoZW1lUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnRvIGBHbG9iYWxTdHlsZXNgXFxuICAgIDxUaGVtZVByb3ZpZGVyIHRoZW1lPXtkYXJrTW9kZSA/IGRhcmtUaGVtZSA6IGxpZ2h0VGhlbWV9PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXREYXJrTW9kZSghZGFya01vZGUpfT5cXG4gICAgICAgICAge2RhcmtNb2RlID8gJ0xpZ2h0IGl0IHVwIScgOiAnVHVybiB0aGUgbGlnaHQgb2ZmISd9XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8R2xvYmFsU3R5bGVzIC8+XFxuICAgICAge2NoaWxkcmVufVxcbiAgICA8L1RoZW1lUHJvdmlkZXI+XFxuICApXFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IExheW91dFxcbmBgYFxcblxcbldlIGNvdWxkIGhhdmUgZ290IHRoZSBgbG9jYWxTdG9yYWdlYCB2YWx1ZSBiZWZvcmUgc2V0dGluZyB0aGUgc3RhdGUsIGJ1dCBgbG9jYWxTdG9yYWdlYFxcbmlzIHN0aWxsIG5vdCBhdmFpbGFibGUgYmVjYXVzZSBpdCdzIG5vdCBwYXJ0IG9mIE5leHRKUywgc28gdGhpcyBpcyBhIG5pY2Ugd29yay1hcm91bmQuXFxuXFxuLS0tXFxuXFxuIyMgV2hhdCB0aGUgZmxhc2g/XFxuXFxuWW91IG1pZ2h0IGhhdmUgbm90aWNlZCB0aGF0IHdoZW4gcmVsb2FkaW5nIHlvdXIgYXBwbGljYXRpb24gd2hpbGUgaW4gZGFyayBtb2RlLFxcbnRoZSBwYWdlIGtpbmQgb2YgX2ZsYXNoZXNfIGJldHdlZW4gbGlnaHQgYW5kIGRhcmsgbW9kZS4gV2VsbCwgd2UgYWxzbyBjYW4gdXNlIGB1c2VFZmZlY3RgXFxuYXMgYSBnb29kIHdvcmstYXJvdW5kIHRvIHByZXZlbnQgdGhhdCwgbGV0J3Mgc2V0IGFub3RoZXIgc3RhdGUg4oCTIGBtb3VudGVkYDpcXG5cXG5gYGBqczo2LDEyLTEzXFxuLy8gLi4uXFxuXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUoKVxcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpXFxuXFxuICB1c2VFZmZlY3QoKCkgPT4ge1xcbiAgICBjb25zdCBkYXJrTW9kZVZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0RBUktfTU9ERScpXFxuICAgIC8vIGxvY2FsU3RvcmFnZSByZXR1cm5zIGEgc3RyaW5nLCBub3QgYSBib29sZWFuXFxuICAgIHNldERhcmtNb2RlKGRhcmtNb2RlVmFsdWUgPT09ICd0cnVlJylcXG4gICAgLy8gU2V0IG1vdW50ZWQgdG8gYHRydWVgIG9ubHkgYWZ0ZXIgc2V0dGluZyB0aGUgYGRhcmtNb2RlYCBzdGF0ZVxcbiAgICBzZXRNb3VudGVkKHRydWUpXFxuICB9LCBbXSlcXG5cXG4gIC8vIC4uLlxcbn1cXG5gYGBcXG5cXG5BbHJpZ2h0LCBub3cgd2UgY2FuIHNpbXBseSByZW5kZXIgYW4gZW1wdHkgYDxkaXYgLz5gIGJlZm9yZSB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQsXFxudGhpcyB3aWxsIHByZXZlbnQgdGhlIGNvbXBvbmVudCB0byByZW5kZXIgb3VyIHN0eWxlcywgYFRoZW1lUHJvdmlkZXJgIGV0YyBiZWZvcmUgd2Ugc2V0IHRoZVxcbmBkYXJrTW9kZWAgc3RhdGU6XFxuXFxuYGBganM6MjRcXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xcbmltcG9ydCB7IFRoZW1lUHJvdmlkZXIgfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cydcXG5cXG5pbXBvcnQgeyBHbG9iYWxTdHlsZXMgfSBmcm9tICcuLi9zdHlsZXMvZ2xvYmFsJ1xcbmltcG9ydCB7IGxpZ2h0VGhlbWUsIGRhcmtUaGVtZSB9IGZyb20gJy4uL3N0eWxlcy90aGVtZXMnXFxuXFxuZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4gfSkge1xcbiAgLy8gVXNlIHRoZSBzdGF0ZSB0byBkZXRlcm1pbmUgZGFya01vZGVcXG4gIGNvbnN0IFtkYXJrTW9kZSwgc2V0RGFya01vZGVdID0gdXNlU3RhdGUoKVxcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpXFxuXFxuICB1c2VFZmZlY3QoKCkgPT4ge1xcbiAgICBjb25zdCBkYXJrTW9kZVZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0RBUktfTU9ERScpXFxuICAgIC8vIGxvY2FsU3RvcmFnZSByZXR1cm5zIGEgc3RyaW5nLCBub3QgYSBib29sZWFuXFxuICAgIHNldERhcmtNb2RlKGRhcmtNb2RlVmFsdWUgPT09ICd0cnVlJylcXG4gICAgLy8gU2V0IG1vdW50ZWQgdG8gYHRydWVgIG9ubHkgYWZ0ZXIgc2V0dGluZyB0aGUgYGRhcmtNb2RlYCBzdGF0ZVxcbiAgICBzZXRNb3VudGVkKHRydWUpXFxuICB9LCBbXSlcXG5cXG4gIHVzZUVmZmVjdCgoKSA9PiB7XFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdEQVJLX01PREUnLCBkYXJrTW9kZSlcXG4gIH0sIFtkYXJrTW9kZV0pIC8vIFJ1biBldmVyeSB0aW1lIGBkYXJrTW9kZWAgY2hhbmdlc1xcblxcbiAgaWYgKCFtb3VudGVkKSByZXR1cm4gPGRpdiAvPlxcblxcbiAgcmV0dXJuIChcXG4gICAgLy8gVGhpcyB3aWxsIHBhc3MgYHRoZW1lYCBmcm9tIGBUaGVtZVByb3ZpZGVyYCBhcyBhIHByb3AgaW50byBgR2xvYmFsU3R5bGVzYFxcbiAgICA8VGhlbWVQcm92aWRlciB0aGVtZT17ZGFya01vZGUgPyBkYXJrVGhlbWUgOiBsaWdodFRoZW1lfT5cXG4gICAgICA8ZGl2PlxcbiAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0RGFya01vZGUoIWRhcmtNb2RlKX0+XFxuICAgICAgICAgIHtkYXJrTW9kZSA/ICdMaWdodCBpdCB1cCEnIDogJ1R1cm4gdGhlIGxpZ2h0IG9mZiEnfVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPEdsb2JhbFN0eWxlcyAvPlxcbiAgICAgIHtjaGlsZHJlbn1cXG4gICAgPC9UaGVtZVByb3ZpZGVyPlxcbiAgKVxcbn1cXG5cXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRcXG5gYGBcXG5cXG5JZiB5b3UgcmVsb2FkIHlvdXIgYXBwbGljYXRpb24sIHRoZSBfZmxhc2hfIGJldHdlZW4gbGlnaHQgYW5kIGRhcmsgbW9kZSBzaG91bGQgYmUgZ29uZS5cXG5cXG4tLS1cXG5cXG4jIyBTb3VyY2UgQ29kZVxcblxcbllvdSBjYW4gZmluZCB0aGUgc291cmNlIGNvZGUgb2YgdGhpcyB0dXRvcmlhbCBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL3RlbG1vZ29uY2FsdmVzL25leHRqcy1tYXJrZG93bi1ibG9nKSxcXG5kb24ndCBmb3JnZXQgaXQncyB1bmRlciB0aGUgYnJhbmNoIGBkYXJrLW1vZGVgLlxcblwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./writings/dark-mode-enabled.md\n");

/***/ })

}]);